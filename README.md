# Projet d'Algo - Conception d'un jeu du labyrinthe

Voici le repo sur lequel on travaillera pour ce projet, tout fichier ou lien utile y est présent (normalement)

Le but : créer un jeu en langage C qui s'affiche dans la console et qui reprend les règles du célèbre jeu éponyme.
On va devoir se concentrer avant tout sur  :
 - la conception du labyrinthe avant de parfaire le jeu en lui-même, car ce sera le coeur de notre programme
 - La jouabilité du jeu (affichage, indications, guidage)
 - Fonctionnalités secondaires (Sauvegarde sur fichier texte, Allegro ?)

Annexes : https://boostcamp.omneseducation.com/course/view.php?id=249881&section=3#tabs-tree-start


# Contenu du dossier à rendre le 08/01/2023 : 
## Le code avec tous les dossiers et fichiers nécessaires (démo de ce code en 15 min max à la soutenance) :
 - Tous les dossiers et fichiers de votre projet développés dans le répertoire de travail de CodeBlocks (fichiers headers .h, fichiers sources .c, projet .cbp, exécutable .exe etc.), et tout autre fichier que vous jugez nécessaire au bon fonctionnement de votre programme (par exemple, fichier(s) de sauvegarde au format .txt).
Remarque : Dans vos appels de fopen, ne précisez aucun chemin de répertoire (sauf s'il est dans un dossier du répertoire de travail de CodeBlocks) pour que vos fichiers .txt soient considérés locaux à l'exécutable.
- Citez vos sources (exemples : extraits de code récupérés de cette page campus, sites web consultés etc.) en commentaires en début de vos fichiers sources .c

## Un PowerPoint (ou Prezi ou Keynote) au format pdf avec les slides suivants (5 min max à la soutenance) :
- Page de garde avec titre, noms coéquipiers et groupe de TD (1 slide)
- Sommaire (1 slide)
- Présentation synthétique et originale sans copier/coller du sujet (vidéo autorisée de 30 secondes max) (1 slide)
- Données, Traitements (fonctionnalités), Entrées/Sorties de l'Interface (DTI) extraits du sujet du projet sous forme de tableau synthétique (1 colonne pour Données, 1 colonne pour Traitements et 1 autre pour Interface) (1 slide)
- Répartition des tâches par fonctionnalités sous forme de tableau (1 slide)
- Algorithmes ou organigrammes (pas de code!) des 3 ou 4 fonctionnalités hors menu les plus pertinentes avec 1 titre chacun  (1 algorithme ou organigramme par slide)
- Choix des structures de données (structures/tableaux…) avec des schémas mémoire clairs sans code (1 slide)
- Graphe d'appels des sous-programmes pour voir la structure générale du code et donc sa modularité. (1 slide)
- BONUS : Versioning GIT : screenshots pour visualiser les commits effectués, les branches de versioning, ceci pour montrer sa bonne utilisation et surtout la bonne répartition du code entre coéquipiers. (1 slide)
- Bilans individuels et collectif sans blabla de l’état du travail effectué, des compétences acquises et des points d'amélioration, sous forme de tableaux synthétiques. (1 à 2 slides)
- Sources précises : web avec tous les liens détaillés, noms des algorithmes utilisés, livres, supports de cours en citant les auteurs (1 slide) avec une dizaine de sources.


#!!! NO PLAGIAT!!!
Chaque code source sera comparé à tous les autres (Paris et Lyon) via un outil spécialisé dans la détection de plagiat de code.  Est considéré comme plagiat toute copie ou tout échange de code entre étudiants ne faisant pas partie de la même équipe.  Si l’échange de code est consentant entre le copieur et le copié, ça sera la même sanction entre les deux parties concernées.

En cas de plagiat avéré, la note de 0/20 sera attribuée à tous les membres des deux groupes concernés, qui seront convoqués en Conseil de Discipline afin de décider d'une punition et de statuer sur leur exclusion de l'école. Tout plagiat sera sévèrement sanctionné par 0 et un avertissement. 

